// GULPFILE INSPIRED FROM:
// http://blog.avisi.nl/2014/04/25/how-to-keep-a-fast-build-with-browserify-and-reactjs/

// MIGHT BE INTERESTING TO LOOK AT AS WELL
// http://lincolnloop.com/blog/speedy-browserifying-multiple-bundles/

// TODO: When in production, use '.min.js'

var _ = require('lodash');
var gulp = require('gulp');
var browserify = require('browserify');
var watchify = require('watchify');
var source = require('vinyl-source-stream');
var reactify = require('reactify');
var streamify = require('gulp-streamify');
var uglify = require('gulp-uglify');
var path = require('path');
var argv = require('yargs').argv;
var arrayize = require('arrayize');

var production = argv.production || process.env.NODE_ENV === 'production';

function _bundle(opts) {

  // options for browserify which are required when using watchify
  var watchifyOptions = {
    cache: {},
    packageCache: {},
    // changing fullPaths has an effect. It allows the package to find modules
    // within itself. But watchify documentation specifically says don't do
    // this.
    //
    // https://github.com/substack/watchify
    //
    // So it's a clue, but not a solution.
    fullPaths: false
  };

  var src = opts.src || null;
  var dest = opts.dest;
  var dev = !production;
  var watch = dev;
  var debug = dev;
  var requires = opts.requires;
  var externals = opts.externals;
  if (!src && !requires) {
    throw "You must specify either a `src` or `requires`";
  }
  var destDirname = path.dirname(dest);
  var destBasename = path.basename(dest);
  var bundler = browserify(src, _.extend({
    debug: dev
    // basedir: process.cwd() // doesn't seem to make a difference
  }, watchifyOptions));

  // Mark anything in externals as external so that it won't be compiled into
  // the bundle.
  arrayize(externals).forEach(function (external) {
    bundler.external(external);
  });

  // WEIRD:
  // When we run this, it makes the modules that we iterate through exposed
  // and available for use outside of this bundle. This bundle can then be
  // used as part of the list of externals in another bundle.
  //
  // HOWEVER, the problems right now is that the modules are not available to
  // other modules IN this bundle.
  //
  // NEAT:
  // Nested requires are properly exposed from the bundle which is even more
  // interesting. In other words, everything seems to work except for the
  // ability of a package to see another required package inside the current
  // bundle.

  // I believe this makes the modules inside available on the outside; however,
  // it does not make the module that was required in available. Only the ones
  // inside the module.
  arrayize(requires).forEach(function (module) {
    bundler.require(module, {expose: true});
    // bundler.require(module);
    // bundler.require(module, {expose: module});
  });

  function log(msg) {
    // console.log(src, requires);
    var from = (src !== null) ? src : JSON.stringify(requires);
    console.log('- ' + from + ': ' + msg);
  }
 
  if(watch) {
    log('watching');
    bundler = watchify(bundler);
    bundler.on('log', log);
  }
 
  // React transformations
  bundler.transform([reactify, {'es6': true}]);

  var rebundle = function() {
    var stream = bundler.bundle();
    stream.on('error', log); // error messages
    stream = stream.pipe(source(destBasename));
    if (production) {
      stream = stream.pipe(streamify(uglify()));
    }
    var returnValue = stream.pipe(gulp.dest(destDirname));
    return returnValue;
  };
 
  bundler.on('update', rebundle);
  // bundler.on('package', function (pkg) {
  //   console.log('on package', pkg.name);
  // })
  // bundler.pipeline.on('package', function (pkg) {
  //   console.log('pipeline.on package', pkg.name);
  // })

  rebundle();

  // console.log('bundler', bundler);

  return bundler;
}

function bundleLib(src, dest, externals) {
  return _bundle({
    requires: src,
    dest: dest,
    watch: true,
    externals: externals
  });
}

function bundle(src, dest, externals) {
  return _bundle({
    src: src,
    dest: dest,
    watch: true,
    externals: externals
  });
}

bundle.lib = bundleLib;

module.exports = bundle;